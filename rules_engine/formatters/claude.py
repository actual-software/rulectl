"""
Claude Code IDE formatter for Rules Engine.

Generates CLAUDE.md file for Claude Code IDE integration.
"""

import yaml
from pathlib import Path
from typing import List, Dict
from datetime import datetime
from .base import BaseFormatter, FormatError


class ClaudeFormatter(BaseFormatter):
    """Formatter for Claude Code IDE CLAUDE.md format."""
    
    def __init__(self):
        super().__init__(
            name='claude',
            description='Single CLAUDE.md file for Claude Code IDE',
            file_extensions=['.md']
        )
    
    def convert(self, mdc_contents: List[str]) -> Dict[str, str]:
        """Convert .mdc contents to Claude Code CLAUDE.md format.
        
        Args:
            mdc_contents: List of .mdc file contents
            
        Returns:
            Dict with single 'CLAUDE.md' key mapping to content
        """
        self.validate_content(mdc_contents)
        
        sections = []
        
        # Add header
        sections.append("# Project Rules")
        sections.append("")
        sections.append("This file contains coding rules and conventions generated by Rules Engine.")
        sections.append("")
        
        for i, content in enumerate(mdc_contents):
            if not content.strip():
                continue
                
            try:
                rule_section = self._convert_mdc_to_claude_section(content, i)
                if rule_section:
                    sections.append(rule_section)
                    sections.append("")  # Add spacing between rules
            except Exception as e:
                # Log warning but continue processing other rules
                print(f"Warning: Failed to convert rule {i+1}: {e}")
                continue
        
        if len(sections) <= 4:  # Only header sections, no actual rules
            raise FormatError("No valid rules could be converted to Claude format")
        
        claude_content = '\n'.join(sections).strip()
        return {'CLAUDE.md': claude_content}
    
    def save(self, content_map: Dict[str, str], target_dir: Path, repo_path: Path) -> List[str]:
        """Save CLAUDE.md file to repository root.
        
        Args:
            content_map: Dict with 'CLAUDE.md' key
            target_dir: Directory to save in (repository root)
            repo_path: Repository root path
            
        Returns:
            List with single CLAUDE.md file path
        """
        if not content_map or 'CLAUDE.md' not in content_map:
            return []
        
        claude_content = content_map['CLAUDE.md']
        if not claude_content.strip():
            return []
        
        claude_file_path = target_dir / 'CLAUDE.md'
        
        # Handle existing CLAUDE.md files
        if claude_file_path.exists():
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            claude_file_path = target_dir / f"CLAUDE_rules_{timestamp}.md"
        
        try:
            claude_file_path.write_text(claude_content, encoding='utf-8')
            return [self._safe_relative_path(claude_file_path, repo_path)]
        except (OSError, UnicodeError) as e:
            raise FormatError(f"Failed to write Claude file {claude_file_path}: {e}")
    
    def supports_merge(self) -> bool:
        """Claude format merges all rules into single file."""
        return True
    
    def _convert_mdc_to_claude_section(self, mdc_content: str, index: int) -> str:
        """Convert single .mdc content to Claude markdown section.
        
        Args:
            mdc_content: Single .mdc file content
            index: Rule index for fallback naming
            
        Returns:
            Markdown section for Claude format
        """
        try:
            # Parse the .mdc content
            yaml_end = mdc_content.find('---', 3)
            if yaml_end > 0:
                front_matter = mdc_content[3:yaml_end].strip()
                parsed = yaml.safe_load(front_matter)
                description = parsed.get('description', f'Rule {index+1}')
                globs = parsed.get('globs', [])
                
                # Extract bullets
                content_after_yaml = mdc_content[yaml_end + 3:].strip()
                bullets = [
                    line.strip('- ').strip() 
                    for line in content_after_yaml.split('\n') 
                    if line.strip().startswith('-')
                ]
                
                # Build Claude section
                section_lines = [f"## {description}"]
                
                # Add scope information if specific globs are provided
                if globs and globs != ['**/*']:
                    section_lines.append("")
                    section_lines.append(f"**Applies to**: {', '.join(globs)}")
                
                # Add bullets
                section_lines.append("")
                for bullet in bullets:
                    section_lines.append(f"- {bullet}")
                
                return '\n'.join(section_lines)
            else:
                # Fallback for malformed content
                return f"## Rule {index+1}\n\n- {mdc_content.strip()}"
                
        except (yaml.YAMLError, AttributeError) as e:
            # Fallback for parsing errors
            return f"## Rule {index+1}\n\n- {mdc_content.strip()}"
    
    def validate_content(self, mdc_contents: List[str]) -> None:
        """Validate content for Claude format conversion.
        
        Args:
            mdc_contents: List of .mdc file contents
            
        Raises:
            FormatError: If content is invalid
        """
        super().validate_content(mdc_contents)
        
        # Additional Claude-specific validation
        valid_rules = 0
        for content in mdc_contents:
            if content.strip():
                # Check if it has some structure (either YAML frontmatter or bullet points)
                has_yaml = '---' in content
                has_bullets = any(line.strip().startswith('-') for line in content.split('\n'))
                
                if has_yaml or has_bullets:
                    valid_rules += 1
        
        if valid_rules == 0:
            raise FormatError("No valid rules found for Claude format conversion")